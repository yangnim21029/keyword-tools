'use server';

import { ALPHABET, LANGUAGES, REGIONS, SYMBOLS } from '@/app/config/constants';
import { getSearchVolume } from '@/app/services/keyword-data.service';
import { analyzeHtmlContent, analyzeSerpResultsHtml, getSerpAnalysis } from '@/app/services/serp';
import { SearchHistoryDetailResult, SearchHistoryListResult, SuggestionsResult } from '@/app/types';
import { UrlFormData } from '@/types';
// import { OpenAI } from 'openai'; // 保持註釋
import { } from '@/app/services/firebase';
import {
  deleteSearchHistory,
  getSearchHistoryDetail as getSearchHistoryDetailFromFirebase,
  getSearchHistoryList,
  saveSearchHistory,
  updateSearchHistoryWithPersonas as updateFirebaseHistoryWithPersonas,
  updateSearchHistoryWithResults as updateFirebaseHistoryWithResults,
  updateSearchHistoryWithClusters
} from '@/app/services/firebase/history';
import { estimateProcessingTime, filterSimplifiedChinese } from '@/app/services/keyword-data.service';
import {
  fetchAutocomplete,
  fetchSuggestionWithDelay,
} from '@/app/services/suggestion.service';
import { revalidateTag } from 'next/cache';

// --- Vercel AI SDK Imports ---
// --- End Vercel AI SDK Imports ---

// const openai_legacy = new OpenAI({ // 保持註釋
//   apiKey: process.env.OPENAI_API_KEY,
// });

// 获取数据库统计信息
export async function getFirebaseStats() {
  try {
    // Example usage of the database stats function
    // export const fetchDatabaseStats = async () => {
    //   try {
    //     const stats = await getDatabaseStats();
    //     console.log("Database stats:", stats);
    //     return stats;
    //   } catch (error) {
    //     console.error("Failed to fetch database stats:", error);
    //     return { error: "Failed to fetch database stats" };
    //   }
    // };

    // Function to fetch search history list
    // const stats = await getDatabaseStats(); // Comment out this line
    // return stats; // Also comment out the return if stats are unavailable
    throw new Error('getDatabaseStats is not implemented'); // Indicate function is not ready
  } catch (error) {
    console.error('獲取數據庫統計信息失敗:', error);
    return { error: '獲取數據庫統計信息失敗' };
  }
}

// Get available regions
export async function getRegions() {
  return { regions: REGIONS, languages: LANGUAGES };
}

// Refactor getKeywordSuggestions to use cache
export async function getKeywordSuggestions(query: string, region: string, language: string, useAlphabet: boolean = true, useSymbols: boolean = false): Promise<SuggestionsResult> {
  'use server';

  const searchPrefix = query.trim();
  // Use a base cache key without alphabet/symbols for simple queries
  // const baseCacheKey = `${searchPrefix}_${region}_${language}`;

  try {
    // 1. Check cache first (only for non-extended searches for simplicity)
    // if (!useAlphabet && !useSymbols) {
    //   const cachedSuggestions = await getCachedKeywordSuggestions(searchPrefix, region, language);
    //   if (cachedSuggestions) {
    //     const estimatedVolumeTime = estimateProcessingTime(cachedSuggestions, true);
    //     return {
    //       suggestions: cachedSuggestions,
    //       estimatedProcessingTime: estimatedVolumeTime,
    //       // fromCache: true, // Removed
    //       sourceInfo: `數據來源: 快取 (${baseCacheKey})` // Removed source info
    //     };
    //   }
    // }

    // 2. If not cached or extended search, fetch from API
    console.log(`從API獲取關鍵詞建議: ${searchPrefix}, 區域: ${region}, 語言: ${language}, A:${useAlphabet}, S:${useSymbols}`);

    let allSuggestions: string[] = [];

    // Base search
    // Ensure fetchAutocomplete uses no-store if it fetches internally
    const baseResults = await fetchAutocomplete(searchPrefix, region, language);
    allSuggestions = [...baseResults];

    // Alphabet expansion
    if (useAlphabet) {
      const alphabetPromises = ALPHABET.map(letter =>
        // Ensure fetchAutocomplete uses no-store
        fetchAutocomplete(`${searchPrefix} ${letter}`, region, language)
      );
      const alphabetResults = await Promise.all(alphabetPromises);
      allSuggestions = [...allSuggestions, ...alphabetResults.flat()];
    }

    // Symbol expansion
    if (useSymbols) {
      const symbolPromises = SYMBOLS.map(symbol =>
        // Ensure fetchAutocomplete uses no-store
        fetchAutocomplete(`${searchPrefix} ${symbol}`, region, language)
      );
      const symbolResults = await Promise.all(symbolPromises);
      allSuggestions = [...allSuggestions, ...symbolResults.flat()];
    }

    // Filter and deduplicate
    let filteredSuggestions = filterSimplifiedChinese(allSuggestions);
    const uniqueSuggestions = [...new Set(filteredSuggestions)];

    // 3. Cache the results (only for non-extended searches for simplicity)
    // if (!useAlphabet && !useSymbols && uniqueSuggestions.length > 0) {
    //   await cacheKeywordSuggestions(searchPrefix, region, language, uniqueSuggestions);
    // }

    // Calculate estimated time
    const estimatedVolumeTime = estimateProcessingTime(uniqueSuggestions, true);

    return {
      suggestions: uniqueSuggestions,
      estimatedProcessingTime: estimatedVolumeTime,
      // fromCache: false, // Removed
      sourceInfo: '數據來源: Google Autocomplete API' // Simplified source info
    };

  } catch (error) {
    console.error('獲取關鍵詞建議時出錯:', error);
    return {
      suggestions: [],
      estimatedProcessingTime: 0,
      // fromCache: false, // Removed
      sourceInfo: '數據來源: 獲取失敗'
    };
  }
}

// Refactor getUrlSuggestions to use cache
export async function getUrlSuggestions(formData: UrlFormData): Promise<SuggestionsResult> {
  'use server';

  const { url, region, language } = formData;

  if (!url) {
    return { suggestions: [], estimatedProcessingTime: 0, error: 'URL 不能為空', sourceInfo: '數據來源: 輸入驗證失敗' };
  }

  try {
    // 1. Check cache first
    // const cachedSuggestions = await getCachedUrlSuggestions(url, region, language);
    // if (cachedSuggestions) {
    //   const estimatedVolumeTime = estimateProcessingTime(cachedSuggestions, true);
    //   return {
    //     suggestions: cachedSuggestions,
    //     estimatedProcessingTime: estimatedVolumeTime,
    //     // fromCache: true, // Removed
    //     sourceInfo: `數據來源: URL 快取 (${url.substring(0, 30)}...)` // Removed source info
    //   };
    // }

    // 2. If not cached, analyze URL and fetch from API
    console.log(`從API分析URL: ${url}, 區域: ${region}, 語言: ${language}`);

    // Extract potential keywords from URL (existing logic)
    const { hostname, pathname } = new URL(url);
    const domain = hostname.replace(/^www\\./, '');
    const domainParts = domain.split('.').filter(part => !['com', 'org', 'net', 'edu', 'gov', 'io', 'co'].includes(part));
    const pathParts = pathname.split('/').filter(part => part && part.length > 2).map(part => part.replace(/-|_/g, ' '));
    const potentialKeywords = [...domainParts, ...pathParts];

    if (potentialKeywords.length === 0) {
      return { suggestions: [], estimatedProcessingTime: 0, error: '無法從 URL 提取關鍵詞', sourceInfo: '數據來源: URL 解析失敗' };
    }

    let allSuggestions: string[] = [];
    // Limit keywords used for fetching to avoid too many requests
    for (const keyword of potentialKeywords.slice(0, 5)) {
      // Ensure fetchAutocomplete uses no-store if it fetches internally
      const suggestions = await fetchAutocomplete(keyword, region, language);
      allSuggestions = [...allSuggestions, ...suggestions];
    }

    // Filter and deduplicate
    let filteredSuggestions = filterSimplifiedChinese(allSuggestions);
    const uniqueSuggestions = [...new Set(filteredSuggestions)];

    console.log(`從 URL 獲取到 ${uniqueSuggestions.length} 個建議`);

    // 3. Cache the results
    // if (uniqueSuggestions.length > 0) {
    //   await cacheUrlSuggestions(url, region, language, uniqueSuggestions);
    // }

    // Calculate estimated time
    const estimatedVolumeTime = estimateProcessingTime(uniqueSuggestions, true);

    return {
      suggestions: uniqueSuggestions,
      estimatedProcessingTime: estimatedVolumeTime,
      // fromCache: false, // Removed
      sourceInfo: '數據來源: URL 分析 + Google Autocomplete API' // Simplified source info
    };

  } catch (error) {
    console.error('獲取 URL 建議時出錯:', error);
    return {
      suggestions: [],
      estimatedProcessingTime: 0,
      error: error instanceof Error ? error.message : '獲取 URL 建議失敗',
      // fromCache: false, // Removed
      sourceInfo: '數據來源: 獲取失敗'
    };
  }
}

// 获取搜索历史列表
export async function fetchSearchHistory(limit: number = 50, forceRefresh: boolean = false): Promise<SearchHistoryListResult> {
  'use server';
  const sourceInfo = '數據來源: Firebase Firestore';
  try {
    // If forceRefresh is requested, revalidate before fetching
    if (forceRefresh) {
        revalidateTag('history');
        console.log('[Server Action] Revalidated history tag due to forceRefresh.');
        // Remove the manual fetch call to /api/revalidate, revalidateTag is sufficient
        // fetch('/api/revalidate', { ... });
    }

    // Assuming getSearchHistoryList fetches fresh data
    const historyList = await getSearchHistoryList(limit);

    return { data: historyList, sourceInfo };
  } catch (error) {
    console.error('獲取搜索歷史失敗:', error);
    if (error instanceof Error &&
        (error.message.includes('RESOURCE_EXHAUSTED') ||
         error.message.includes('Quota exceeded'))) {
      return {
        data: [],
        sourceInfo,
        error: `配額超出: ${error.message}`
      };
    }
    return {
      data: [],
      sourceInfo,
      error: error instanceof Error ? error.message : '獲取搜索歷史失敗'
    };
  }
}

// 获取搜索历史详情 (Remove noCache parameter as it's irrelevant now)
export async function fetchSearchHistoryDetail(historyId: string): Promise<SearchHistoryDetailResult> {
  'use server';
  const sourceInfo = '數據來源: Firebase Firestore';
  if (!historyId) {
    return { data: null, sourceInfo, error: '需要提供 historyId' };
  }
  try {
    console.log(`[Server Action] Fetching history detail for: ${historyId}`);
    // Use the specific Firebase fetch function
    const historyDetail = await getSearchHistoryDetailFromFirebase(historyId);

    if (!historyDetail) {
      return { data: null, sourceInfo, error: '找不到指定的搜索歷史記錄' };
    }

    // Revalidate the specific tag for this detail item
    revalidateTag(`history-${historyId}`);

    return { data: historyDetail, sourceInfo };
  } catch (error) {
    console.error(`獲取搜索歷史詳情 (${historyId}) 失敗:`, error);
    return {
      data: null,
      sourceInfo,
      error: error instanceof Error ? error.message : '獲取搜索歷史詳情失敗'
    };
  }
}

// 删除搜索历史记录
export async function deleteSearchHistoryRecord(historyId: string) {
  'use server';
  try {
    await deleteSearchHistory(historyId);
    revalidateTag('history'); // Revalidate the list after deletion
    revalidateTag(`history-${historyId}`); // Also revalidate the detail tag
    console.log(`[Server Action] Deleted history record ${historyId} and revalidated tags 'history', 'history-${historyId}'.`);
    return { success: true };
  } catch (error) {
    console.error(`刪除搜索歷史記錄 (${historyId}) 失敗:`, error);
    return { success: false, error: '刪除失敗' };
  }
}

// 保存包含聚类的搜索历史
export async function saveClustersToHistory(
  mainKeyword: string,
  region: string,
  language: string,
  suggestions: string[],
  searchResults: any[], // Consider defining a stricter type
  clusters: Record<string, string[]>
) {
  'use server';
  try {
    const historyId = await saveSearchHistory(mainKeyword, region, language, suggestions, searchResults, clusters);
    revalidateTag('history'); // Revalidate the list after saving
    // No specific detail tag to revalidate yet, as it's a new item
    console.log(`[Server Action] Saved new history record ${historyId} with clusters and revalidated tag 'history'.`);
    return { success: true, historyId };
  } catch (error) {
    console.error('保存含聚類的歷史記錄失敗:', error);
    return { success: false, error: '保存失敗' };
  }
}

// 更新历史记录的聚类信息
export async function updateHistoryWithClusters(
  historyId: string,
  clusters: Record<string, string[]>
) {
  'use server';
  try {
    await updateSearchHistoryWithClusters(historyId, clusters);
    revalidateTag('history'); // Revalidate the list
    revalidateTag(`history-${historyId}`); // Revalidate the specific detail
    console.log(`[Server Action] Updated clusters for history ${historyId} and revalidated tags 'history', 'history-${historyId}'.`);
    return { success: true };
  } catch (error) {
    console.error(`更新歷史記錄 (${historyId}) 的聚類失敗:`, error);
    return { success: false, error: '更新聚類失敗' };
  }
}

// 保存历史记录的聚类结果 (Seems similar to updateHistoryWithClusters, ensure purpose is distinct or merge)
export async function saveHistoryClusteringResults(historyId: string, clusters: Record<string, string[]>) {
  'use server';
  try {
    // Assuming this also updates the history document
    await updateSearchHistoryWithClusters(historyId, clusters); // Reusing the update function, adjust if needed
    revalidateTag('history');
    revalidateTag(`history-${historyId}`);
    console.log(`[Server Action] Saved clustering results for history ${historyId} and revalidated tags 'history', 'history-${historyId}'.`);
    return { success: true };
  } catch (error) {
    console.error(`保存歷史記錄 (${historyId}) 的聚類結果失敗:`, error);
    return { success: false, error: '保存聚類結果失敗' };
  }
}

// 获取单个历史记录的详细信息 (This might be redundant with fetchSearchHistoryDetail, review usage)
// Keeping it for now, ensure it fetches fresh data
export async function getHistoryDetail(historyId: string) {
    'use server';
    try {
        console.log(`[Server Action] Getting detail for history: ${historyId}`);
        // Use the specific Firebase fetch function
        const detailData = await getSearchHistoryDetailFromFirebase(historyId);
        if (!detailData) {
            console.warn(`[Server Action] No detail found for history: ${historyId}`);
            return null;
        }
        // Revalidate the specific tag after fetching (optional, depending on usage pattern)
        // revalidateTag(`history-${historyId}`);
        return detailData;
    } catch (error) {
        console.error(`獲取歷史詳情 (${historyId}) 時出錯:`, error);
        throw error; // Re-throw to be caught by caller like fetchSearchHistoryDetail
    }
}

// Placeholder for the actual Firebase fetch function - needs implementation in firebase/history.ts
// async function getSearchHistoryDetailFromFirebase(historyId: string): Promise<any | null> {
//     // Implement the actual Firestore fetch logic here in the imported file
//     console.warn(`[Firebase Service] Placeholder: Need to implement Firebase fetch for history ID: ${historyId}`);
//     return { id: historyId, placeholder: true, fetchedAt: new Date() }; // Return placeholder data for now
// }

// 获取带延迟的关键字建议 (Remove cache logic if any existed in fetchSuggestionWithDelay)
export async function getKeywordSuggestionsWithDelay(query: string, region: string, language: string): Promise<SuggestionsResult> {
  'use server';
  try {
    console.log(`[Server Action] Fetching delayed suggestions for: ${query}`);
    // Assuming fetchSuggestionWithDelay returns string[] on success and throws on error
    const suggestionsArray = await fetchSuggestionWithDelay(query, region, language);

    // If fetchSuggestionWithDelay completed without throwing, it succeeded
    return {
      suggestions: suggestionsArray, // Use the returned array directly
      estimatedProcessingTime: 0, // Delay function doesn't estimate volume time
      // fromCache: false, // Removed - Implicitly false now
      sourceInfo: '數據來源: Google Autocomplete API (Delayed)'
    };
  } catch (error) {
    console.error('獲取帶延遲的關鍵詞建議時出錯:', error);
    const errorMessage = error instanceof Error ? error.message : '獲取失敗';
    return {
      suggestions: [],
      estimatedProcessingTime: 0,
      // fromCache: false, // Removed - Implicitly false now
      sourceInfo: '數據來源: 獲取失敗',
      error: errorMessage // Include the error message in the result
    };
  }
}

// 更新搜索历史记录的搜索结果
export async function updateSearchHistoryWithResults(
  historyId: string,
  searchResults: any[] // Define a stricter type
) {
  'use server';
  try {
    // Use the specific Firebase update function
    await updateFirebaseHistoryWithResults(historyId, searchResults);
    revalidateTag('history');
    revalidateTag(`history-${historyId}`);
    console.log(`[Server Action] Updated search results for history ${historyId} and revalidated tags 'history', 'history-${historyId}'.`);
    return { success: true };
  } catch (error) {
    console.error(`更新歷史記錄 (${historyId}) 的搜索結果失敗:`, error);
    return { success: false, error: '更新搜索結果失敗' };
  }
}

// Placeholder for the actual Firebase update function - needs implementation in firebase/history.ts
// async function updateFirebaseHistoryWithResults(historyId: string, searchResults: any[]): Promise<void> {
//     // Implement the actual Firestore update logic here in the imported file
//     console.warn(`[Firebase Service] Placeholder: Need to implement Firebase update results for history ID: ${historyId}`);
// }

// 更新搜索历史记录的人物画像信息
export async function updateSearchHistoryWithPersonas(
  historyId: string,
  personas: any[] // Define a stricter type
) {
  'use server';
  try {
    await updateFirebaseHistoryWithPersonas(historyId, personas);
    revalidateTag('history');
    revalidateTag(`history-${historyId}`);
    console.log(`[Server Action] Updated personas for history ${historyId} and revalidated tags 'history', 'history-${historyId}'.`);
    return { success: true };
  } catch (error) {
    console.error(`更新歷史記錄 (${historyId}) 的人物画像失敗:`, error);
    return { success: false, error: '更新人物画像失敗' };
  }
}

// 導出導入的服務函數 (假設它們本身是 async)
export {
  analyzeHtmlContent,
  analyzeSerpResultsHtml, getSearchVolume, getSerpAnalysis
};

// Add new action for saving basic keyword research
export async function saveKeywordResearch(
  mainKeyword: string,
  region: string,
  language: string,
  suggestions: string[],
  searchResults: any[] // Consider defining a stricter type
) {
  'use server';
  try {
    // Directly call the function from history.ts
    const historyId = await saveSearchHistory(mainKeyword, region, language, suggestions, searchResults, null); // Pass null for clusters
    if (!historyId) {
      throw new Error('Failed to get history ID after saving.');
    }
    revalidateTag('history'); // Revalidate the list after saving
    console.log(`[Server Action] Saved new keyword research history ${historyId} and revalidated tag 'history'.`);
    return { success: true, historyId };
  } catch (error) {
    console.error('保存關鍵詞研究歷史記錄失敗:', error);
    return { success: false, error: error instanceof Error ? error.message : '保存失敗' };
  }
}

